(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{327:function(v,_,e){"use strict";e.r(_);var o=e(33),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器渲染机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[v._v("#")]),v._v(" 浏览器渲染机制")]),v._v(" "),e("h2",{attrs:{id:"进程-线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程-线程"}},[v._v("#")]),v._v(" 进程/线程")]),v._v(" "),e("blockquote",[e("p",[v._v("进程（"),e("code",[v._v("process")]),v._v("）是程序的一次执行过程，程序在执行过程种分配和管理资源的基本单位。")])]),v._v(" "),e("blockquote",[e("p",[v._v("线程（"),e("code",[v._v("thread")]),v._v("）是"),e("code",[v._v("CPU")]),v._v("调度和分配的基本单位，可以和同一个进程的其他线程共享进程所拥有的全部资源")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("浏览器地址输入一个"),e("code",[v._v("URL")]),v._v("，浏览器根据"),e("code",[v._v("DNS")]),v._v("服务器得到域名的"),e("code",[v._v("IP")]),v._v("地址，这个时候浏览器进程会向这个"),e("code",[v._v("IP")]),v._v("地址发送请求，获取"),e("code",[v._v("HTML")]),v._v("内容。然后将这些内容交给渲染进程。渲染进程解析内容，解析遇到的请求网络的资源又返回来交给浏览器进程进行加载，同时通知主进程（浏览器进程），需要插件进程加载插件资源，执行插件代码。解析完成后，渲染进程得到图像帧，并交给"),e("code",[v._v("GPU")]),v._v("进程，将其转化为图像显示屏幕。"),e("RouterLink",{attrs:{to:"/basis/JavaScript/Event-Loop.html#浏览器包含了哪些进程"}},[v._v("四种进程介绍")])],1)]),v._v(" "),e("blockquote",[e("p",[v._v("首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入"),e("code",[v._v("URL")]),v._v("，这个时候"),e("code",[v._v("Browser Process")]),v._v("会向这个"),e("code",[v._v("URL")]),v._v("发送请求，获取这个"),e("code",[v._v("URL")]),v._v("的"),e("code",[v._v("HTML")]),v._v("内容，然后将"),e("code",[v._v("HTML")]),v._v("交给"),e("code",[v._v("Renderer Process")]),v._v("，"),e("code",[v._v("Renderer Process")]),v._v("解析"),e("code",[v._v("HTML")]),v._v("内容，解析遇到需要请求网络的资源又返回来交给"),e("code",[v._v("Browser Process")]),v._v("进行加载，同时通知"),e("code",[v._v("Browser Process")]),v._v("，需要"),e("code",[v._v("Plugin Process")]),v._v("加载插件资源，执行插件代码。解析完成后，"),e("code",[v._v("Renderer Process")]),v._v("计算得到图像帧，并将这些图像帧交给"),e("code",[v._v("GPU Process")]),v._v("，"),e("code",[v._v("GPU Process")]),v._v("将其转化为图像显示屏幕。")])]),v._v(" "),e("h3",{attrs:{id:"浏览器进程模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程模式"}},[v._v("#")]),v._v(" 浏览器进程模式")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("Chrome浏览器多进程的好处：")]),v._v(" "),e("ol",[e("li",[v._v("更高的容错性。当今"),e("code",[v._v("WEB")]),v._v("应用中，"),e("code",[v._v("HTML，JavaScript")]),v._v("和"),e("code",[v._v("CSS")]),v._v("日益复杂，这些跑在渲染引擎的代码，频繁的出现BUG，而有些"),e("code",[v._v("BUG")]),v._v("会直接导致渲染引擎崩溃，多进程架构使得每一个渲染引擎运行在各自的进程中，相互之间不受影响，也就是说，当其中一个页面崩溃挂掉之后，其他页面还可以正常的运行不收影响。")]),v._v(" "),e("li",[v._v("更高的安全性和沙盒性（"),e("code",[v._v("sanboxing")]),v._v("）。渲染引擎会经常性的在网络上遇到不可信、甚至是恶意的代码，它们会利用这些漏洞在你的电脑上安装恶意的软件，针对这一问题，浏览器对不同进程限制了不同的权限，并为其提供沙盒运行环境，使其更安全更可靠。")]),v._v(" "),e("li",[v._v("更高的响应速度。在单进程的架构中，各个任务相互竞争抢夺"),e("code",[v._v("CPU")]),v._v("资源，使得浏览器响应速度变慢，而多进程架构正好规避了这一缺点。")])])]),v._v(" "),e("blockquote",[e("p",[v._v("为了节省内存，Chrome提供了四种进程模式（"),e("code",[v._v("Process Models")]),v._v("），不同的进程模式会对 "),e("code",[v._v("tab")]),v._v(" 进程做不同的处理。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Process-per-site-instance (default)")]),v._v(" - 同一个 "),e("code",[v._v("site-instance")]),v._v(" 使用一个进程")])]),v._v(" "),e("blockquote",[e("p",[v._v("当你打开一个 "),e("code",[v._v("tab")]),v._v(" 访问 "),e("code",[v._v("a.baidu.com")]),v._v(" ，然后再打开一个 "),e("code",[v._v("tab")]),v._v(" 访问 "),e("code",[v._v("b.baidu.com")]),v._v("，这两个 "),e("code",[v._v("tab")]),v._v(" 会使用两个进程。而如果你在 "),e("code",[v._v("a.baidu.com")]),v._v(" 中，通过JS代码打开了 "),e("code",[v._v("b.baidu.com")]),v._v(" 页面，这两个 tab 会使用同一个进程。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Process-per-site")]),v._v("：同一个"),e("code",[v._v("site")]),v._v("一个进程")]),v._v(" "),e("li",[e("code",[v._v("Process-per-tab")]),v._v("：每个"),e("code",[v._v("tab")]),v._v("使用一个进程")]),v._v(" "),e("li",[e("code",[v._v("single Process")]),v._v("：所有"),e("code",[v._v("tab")]),v._v("共用一个进程")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("site")]),v._v(" 指的是相同的 "),e("code",[v._v("registered domain name")]),v._v("(如："),e("code",[v._v("google.com")]),v._v(" ，"),e("code",[v._v("bbc.co.uk")]),v._v(")和"),e("code",[v._v("scheme")]),v._v(" (如："),e("code",[v._v("https://")]),v._v(")。比如"),e("code",[v._v("a.baidu.com")]),v._v("和"),e("code",[v._v("b.baidu.com")]),v._v("就可以理解为同一个 "),e("code",[v._v("site")]),v._v("（注意这里要和 "),e("code",[v._v("Same-origin policy")]),v._v(" 区分开来，同源策略还涉及到子域名和端口）。")]),v._v(" "),e("li",[e("code",[v._v("site-instance")]),v._v(" 指的是一组 "),e("code",[v._v("connected pages from the same site")]),v._v("，这里 "),e("code",[v._v("connected")]),v._v(" 的定义是 "),e("code",[v._v("can obtain references to each other in script code")]),v._v(" 怎么理解这段话呢。满足下面两情况并且打开的新页面和旧页面属于上面定义的同一个 "),e("code",[v._v("site")]),v._v("，就属于同一个 "),e("code",[v._v("site-instance")]),v._v(" "),e("ul",[e("li",[v._v("用户通过"),e("code",[v._v('<a target="_blank">')]),v._v("这种方式点击打开的新页面")]),v._v(" "),e("li",[e("code",[v._v("JS")]),v._v("代码打开的新页面（比如 "),e("code",[v._v("window.open")]),v._v(")")])])])])]),v._v(" "),e("h2",{attrs:{id:"解析文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析文档"}},[v._v("#")]),v._v(" 解析文档")]),v._v(" "),e("p",[v._v("上述有提到渲染进程会解析内容，然后遇到请求网络的资源就会返回给浏览器进程进行加载，那么解析这个过程又是如何进行的呢？")]),v._v(" "),e("h3",{attrs:{id:"构建dom树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建dom树"}},[v._v("#")]),v._v(" 构建"),e("code",[v._v("DOM")]),v._v("树")]),v._v(" "),e("p",[v._v("渲染进程的主线程开始工作，解析"),e("code",[v._v("HTML")]),v._v("文本并转为"),e("code",[v._v("DOM")]),v._v("树")]),v._v(" "),e("h3",{attrs:{id:"子资源加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#子资源加载"}},[v._v("#")]),v._v(" 子资源加载")]),v._v(" "),e("p",[v._v("当主线程解析遇到一些需要额外加载的资源时，如图片，"),e("code",[v._v("CSS")]),v._v("和"),e("code",[v._v("JavaScript")]),v._v("，为了提高请求速度，会向浏览器进程的网络线程发起请求。")]),v._v(" "),e("h3",{attrs:{id:"js阻塞解析过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js阻塞解析过程"}},[v._v("#")]),v._v(" JS阻塞解析过程")]),v._v(" "),e("p",[v._v("当"),e("code",[v._v("HTML")]),v._v("解析器遇到"),e("code",[v._v("script")]),v._v("标签时，会暂停"),e("code",[v._v("HTML")]),v._v("解析工作，转而去加载"),e("code",[v._v("Js")]),v._v("代码。因为这部分代码可能会影响文档结构。也会导致"),e("code",[v._v("CSSOM")]),v._v("也阻塞。")]),v._v(" "),e("h3",{attrs:{id:"样式计算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[v._v("#")]),v._v(" 样式计算")]),v._v(" "),e("p",[v._v("主线程解析计算完"),e("code",[v._v("CSS")]),v._v("产生"),e("code",[v._v("CSS")]),v._v("规则树，才会对文档节点赋予最终的样式。")]),v._v(" "),e("blockquote",[e("p",[v._v("处理过程：1.把"),e("code",[v._v("CSS")]),v._v("转换成浏览器能够理解的结构--"),e("code",[v._v("StyleSheets")]),v._v("，该结构同时具备了查询和修改功能。2.转换样式表中的属性值，使其标准化。3.计算出"),e("code",[v._v("DoM")]),v._v("树中的每个节点具体样式")])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("CSS")]),v._v("加载会阻塞页面显示吗？")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("css")]),v._v("加载不会阻塞"),e("code",[v._v("DOM")]),v._v("树的解析")]),v._v(" "),e("li",[e("code",[v._v("css")]),v._v("加载会阻塞"),e("code",[v._v("DOM")]),v._v("树的渲染")]),v._v(" "),e("li",[e("code",[v._v("css")]),v._v("加载会阻塞后面"),e("code",[v._v("js")]),v._v("语句的执行")])])]),v._v(" "),e("li",[e("p",[v._v("下载"),e("code",[v._v("CSS")]),v._v("文件阻塞了，会阻塞"),e("code",[v._v("DOM")]),v._v("树的合成吗？会阻塞页面的显示吗？")])])]),v._v(" "),e("blockquote",[e("p",[v._v("不会阻塞"),e("code",[v._v("dom")]),v._v("树构建的，因为"),e("code",[v._v("HTML")]),v._v("转化为"),e("code",[v._v("dom")]),v._v("树的过程，发现文件请求会交给网络进程去请求对应文件，渲染进程继续解析"),e("code",[v._v("HTML")]),v._v("。\n会阻塞页面的显示，当计算样式的时候需要等待"),e("code",[v._v("css")]),v._v("文件的资源进行层叠样式，资源阻塞了，会进行等待，直到网络超时，"),e("code",[v._v("network")]),v._v("报出错误，渲染进程继续层叠样式计算。")])]),v._v(" "),e("h3",{attrs:{id:"布局（初次回流）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#布局（初次回流）"}},[v._v("#")]),v._v(" 布局（初次回流）")]),v._v(" "),e("blockquote",[e("p",[v._v("主线程遍历"),e("code",[v._v("DOM")]),v._v("并计算样式，创建一个具体横纵坐标以及盒子边界大小数据的布局树（"),e("code",[v._v("layout tree")]),v._v("）。布局树可能与"),e("code",[v._v("DOM")]),v._v("树相似，但它只包含和页面即将呈现的节点相关的信息。如果某个元素设置了"),e("code",[v._v("display: none")]),v._v("，虽然它会呈现在"),e("code",[v._v("DOM")]),v._v("树中但并不会包含于布局树当中；如果有一个伪类元素"),e("code",[v._v("p::before{ content: 'Hi!' }")]),v._v("， 那么它虽然不在"),e("code",[v._v("DOM")]),v._v("树中，但仍然会出现在布局树当中。")])]),v._v(" "),e("h3",{attrs:{id:"分层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[v._v("#")]),v._v(" 分层")]),v._v(" "),e("p",[v._v("渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树。拥有层叠上下文的元素会被单独提升为一层；需要剪裁的地方会被创建为图层（当超出容器内容被隐藏或出现滚动条均会被提升为单独层）")]),v._v(" "),e("h3",{attrs:{id:"图层绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[v._v("#")]),v._v(" 图层绘制")]),v._v(" "),e("p",[v._v("渲染引擎对图层树每个图层进行绘制。渲染引擎会把一个图层的绘制分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。当图层的绘制列表准备好之后，主线程会把绘制列表交给合成线程。")]),v._v(" "),e("h3",{attrs:{id:"栅格化操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#栅格化操作"}},[v._v("#")]),v._v(" 栅格化操作")]),v._v(" "),e("blockquote",[e("p",[v._v("将图块转换为位图，而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在里面执行的。")])]),v._v(" "),e("h3",{attrs:{id:"合成和显示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[v._v("#")]),v._v(" 合成和显示")]),v._v(" "),e("p",[v._v("一旦所有图块都栅格化，合成线程会生成一个绘制图块的命令，然后将该命令提交给浏览器进程。浏览器进程的"),e("code",[v._v("viz")]),v._v("组件接收合成线程发过来的命令。然后根据命令将其内容绘制到内存中，最后再将内存显示在屏幕上")]),v._v(" "),e("h2",{attrs:{id:"性能优化策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化策略"}},[v._v("#")]),v._v(" 性能优化策略")]),v._v(" "),e("blockquote",[e("p",[v._v("基于上面介绍的浏览器渲染原理，"),e("code",[v._v("DOM")]),v._v(" 和 "),e("code",[v._v("CSSOM")]),v._v(" 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("JS")]),v._v("优化： "),e("code",[v._v("<script>")]),v._v(" 标签加上 "),e("code",[v._v("defer")]),v._v("属性 和 "),e("code",[v._v("async")]),v._v("属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。"),e("code",[v._v("defer")]),v._v("属性：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。"),e("code",[v._v("async")]),v._v("属性："),e("code",[v._v("HTML5")]),v._v("新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[e("strong",[e("code",[v._v("defer")]),v._v("特性")]),v._v("\n换句话说：")]),v._v(" "),e("ul",[e("li",[v._v("具有 "),e("code",[v._v("defer")]),v._v(" 特性的脚本不会阻塞页面。")]),v._v(" "),e("li",[v._v("具有 "),e("code",[v._v("defer")]),v._v(" 特性的脚本总是要等到 "),e("code",[v._v("DOM")]),v._v(" 解析完毕，但在 "),e("code",[v._v("DOMContentLoaded")]),v._v(" 事件之前执行。")]),v._v(" "),e("li",[v._v("该特性仅适用于外部脚本，如果 "),e("code",[v._v("<script>")]),v._v(" 脚本没有 "),e("code",[v._v("src")]),v._v("，则会忽略 "),e("code",[v._v("defer")]),v._v(" 特性。")])]),v._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("script defer src"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[v._v('"https://javascript.info/article/script-async-defer/long.js"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v("script"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("script defer src"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[v._v('"https://javascript.info/article/script-async-defer/small.js"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v("script"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br")])]),e("blockquote",[e("p",[v._v("浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。"),e("code",[v._v("small.js")]),v._v(" 可能会先下载完成。但是，"),e("code",[v._v("defer")]),v._v(" 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。因此，即使"),e("code",[v._v("small.js")]),v._v(" 先加载完成，它也需要等到 "),e("code",[v._v("long.js")]),v._v(" 执行结束才会被执行。")])]),v._v(" "),e("p",[e("strong",[e("code",[v._v("async")]),v._v("特性")]),v._v(" "),e("code",[v._v("async")]),v._v(" 特性意味着脚本是完全独立的：")]),v._v(" "),e("ul",[e("li",[v._v("浏览器不会因 "),e("code",[v._v("async")]),v._v(" 脚本而阻塞（与 "),e("code",[v._v("defer")]),v._v(" 类似）。")]),v._v(" "),e("li",[v._v("其他脚本不会等待 "),e("code",[v._v("async")]),v._v(" 脚本加载完成，同样，"),e("code",[v._v("async")]),v._v(" 脚本也不会等待其他脚本。")]),v._v(" "),e("li",[e("code",[v._v("DOMContentLoaded")]),v._v(" 和异步脚本不会彼此等待：\n"),e("ul",[e("li",[e("code",[v._v("DOMContentLoaded")]),v._v(" 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）")]),v._v(" "),e("li",[e("code",[v._v("DOMContentLoaded")]),v._v(" 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 "),e("code",[v._v("HTTP")]),v._v(" 缓存中加载的）")])])])]),v._v(" "),e("p",[v._v("换句话说，"),e("code",[v._v("async")]),v._v(" 脚本会在后台加载，并在加载就绪时运行。"),e("code",[v._v("DOM")]),v._v(" 和其他脚本不会等待它们，它们也不会等待其它的东西。"),e("code",[v._v("async")]),v._v(" 脚本就是一个会在加载完成时执行的完全独立的脚本。")]),v._v(" "),e("p",[e("strong",[v._v("动态添加脚本")]),v._v("\n当脚本被附加到文档 (*) 时，脚本就会立即开始加载。默认情况下，动态脚本的行为是“异步”的。\n也就是说：")]),v._v(" "),e("ul",[e("li",[v._v("它们不会等待任何东西，也没有什么东西会等它们。")]),v._v(" "),e("li",[v._v("先加载完成的脚本先执行（“加载优先”顺序）。")])]),v._v(" "),e("p",[v._v("如果我们显式地设置了 "),e("code",[v._v("script.async=false")]),v._v("，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像 "),e("code",[v._v("defer")]),v._v(" 那样。")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("CSS")]),v._v("优化："),e("code",[v._v("<link>")]),v._v(" 标签的 "),e("code",[v._v("rel")]),v._v("属性 中的属性值设置为 "),e("code",[v._v("preload")]),v._v(" 能够让你在你的"),e("code",[v._v("HTML")]),v._v("页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能。")])]),v._v(" "),e("h2",{attrs:{id:"渲染过程总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程总结"}},[v._v("#")]),v._v(" 渲染过程总结")]),v._v(" "),e("blockquote",[e("p",[v._v("当浏览器获取"),e("code",[v._v("HTML")]),v._v("文件后，会自上而下加载并在加载过程中进行解析和渲染；加载就是获取资源的过程；如果在加载过程中遇到外部的"),e("code",[v._v("css")]),v._v("文件和图片，浏览器会另外发送一个请求，去获取"),e("code",[v._v("css")]),v._v("文件和图片，这个请求是异步的，并不会影响"),e("code",[v._v("HTML")]),v._v("文件的加载；但如果遇到"),e("code",[v._v("JavaScript")]),v._v("文件，"),e("code",[v._v("HTML")]),v._v("文件会挂起渲染的进程，等待"),e("code",[v._v("JavaScript")]),v._v("文件加载完毕后，再继续进行渲染。")])]),v._v(" "),e("ol",[e("li",[v._v("浏览器解析"),e("code",[v._v("HTML")]),v._v("，"),e("code",[v._v("CSS")]),v._v("和"),e("code",[v._v("JavaScript")]),v._v("脚本。等脚本加载后，通过 "),e("code",[v._v("DOM API")]),v._v(" 和 "),e("code",[v._v("CSSOM API")]),v._v(" 来操作 "),e("code",[v._v("DOM Tree")]),v._v(" 和 "),e("code",[v._v("CSS Rule Tree")]),v._v("。")]),v._v(" "),e("li",[v._v("解析完成后，浏览器引擎通过两种树结构来构造渲染树。"),e("strong",[v._v("渲染树只包含可见节点")])])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ul",[e("li",[v._v("构建渲染树的过程，浏览器还做了一些关键的小动作：\n"),e("ul",[e("li",[v._v("从"),e("code",[v._v("DOM")]),v._v("树的根节点开始遍历，筛选出所有可见的节点；")]),v._v(" "),e("li",[v._v("仅针对可见节点，为其匹配"),e("code",[v._v("CSSOM")]),v._v("中的"),e("code",[v._v("CSS")]),v._v("规则；")]),v._v(" "),e("li",[v._v("发射可见节点，连同其内容和计算样式。")])])])])]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("code",[v._v("Layout")]),v._v("回流：根据生成的渲染树，进行回流，得到节点的几何信息。")]),v._v(" "),e("li",[v._v("重绘：根据渲染树以及回流得到的几何信息，得到节点的绝对像素")]),v._v(" "),e("li",[v._v("将像素发给"),e("code",[v._v("GPU")]),v._v("进程，展示在页面上。")])]),v._v(" "),e("h2",{attrs:{id:"回流-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[v._v("#")]),v._v(" 回流("),e("code",[v._v("Reflow")]),v._v(")")]),v._v(" "),e("blockquote",[e("p",[v._v("回流是布局或者几何属性需要改变就称为回流。"),e("strong",[v._v("回流一定会导致重绘")])])]),v._v(" "),e("ul",[e("li",[v._v("什么情况会回流（为了求一个即时性和准确性）\n"),e("ul",[e("li",[v._v("添加或者删除可见的"),e("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),e("li",[v._v("元素的位置发生变化")]),v._v(" "),e("li",[v._v("元素的尺寸发生变化")]),v._v(" "),e("li",[v._v("内容发生变化")]),v._v(" "),e("li",[e("strong",[v._v("页面一开始的时候")])]),v._v(" "),e("li",[v._v("浏览器的窗口尺寸变化")]),v._v(" "),e("li",[v._v("设置"),e("code",[v._v("style")]),v._v("属性的值")]),v._v(" "),e("li",[v._v("计算"),e("code",[v._v("offsetWidth/offsetHeight/clientWidth/等")]),v._v("的属性")]),v._v(" "),e("li",[v._v("调用"),e("code",[v._v("getComputedStyle/currentStyle")])])])])]),v._v(" "),e("h2",{attrs:{id:"重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[v._v("#")]),v._v(" 重绘("),e("code",[v._v("Repaint")]),v._v(")")]),v._v(" "),e("blockquote",[e("p",[v._v("重绘是当前节点需要更改外观而不会影响布局。"),e("strong",[v._v("重绘不一定会引起回流")])])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("ul",[e("li",[v._v("并且很多人不知道的是，重绘和回流其实也和 "),e("code",[v._v("Eventloop")]),v._v(" 有关。\n"),e("ul",[e("li",[v._v("当 "),e("code",[v._v("Eventloop")]),v._v(" 执行完 "),e("code",[v._v("Microtasks")]),v._v(" 后，会判断 "),e("code",[v._v("document")]),v._v(" 是否需要更新，因为浏览器是 "),e("code",[v._v("60Hz")]),v._v(" 的刷新率，每 "),e("code",[v._v("16.6ms")]),v._v(" 才会更新一次。")]),v._v(" "),e("li",[v._v("然后判断是否有 "),e("code",[v._v("resize")]),v._v(" 或者 "),e("code",[v._v("scroll")]),v._v(" 事件，有的话会去触发事件，所以 "),e("code",[v._v("resize")]),v._v(" 和 "),e("code",[v._v("scroll")]),v._v(" 事件也是至少 "),e("code",[v._v("16ms")]),v._v(" 才会触发一次，并且自带节流功能。")]),v._v(" "),e("li",[v._v("判断是否触发了 "),e("code",[v._v("media query")])]),v._v(" "),e("li",[v._v("更新动画并且发送事件")]),v._v(" "),e("li",[v._v("判断是否有全屏操作事件")]),v._v(" "),e("li",[v._v("执行 "),e("code",[v._v("requestAnimationFrame")]),v._v(" 回调")]),v._v(" "),e("li",[v._v("执行 "),e("code",[v._v("IntersectionObserver")]),v._v(" 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好")]),v._v(" "),e("li",[v._v("更新界面")]),v._v(" "),e("li",[v._v("以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 "),e("code",[v._v("requestIdleCallback")]),v._v(" 回调。")])])])])]),v._v(" "),e("h2",{attrs:{id:"减少重绘与回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减少重绘与回流"}},[v._v("#")]),v._v(" 减少重绘与回流")]),v._v(" "),e("ul",[e("li",[v._v("合并多次对"),e("code",[v._v("DOM")]),v._v("和样式的修改，然后一次性处理掉")]),v._v(" "),e("li",[v._v("使用"),e("code",[v._v("transform")]),v._v("替代"),e("code",[v._v("top")]),v._v("（"),e("code",[v._v("css3")]),v._v("的硬件加速，不会引起重绘回流。还有"),e("code",[v._v("opacity")]),v._v("，"),e("code",[v._v("filters")]),v._v(","),e("code",[v._v("Will-change")]),v._v("这些属性）")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("opacity")]),v._v("单词意思为透明度，直观视觉效果就是颜色变淡了，但最终显示的颜色其实仍然可以用"),e("code",[v._v("RGB")]),v._v("三个通道来表示，从数值运算的角度来看，它实际上表示了它采用一般混合策略和其他颜色进行混合时的比例。"),e("code",[v._v("显示颜色 = 合入色 x opacity + 底色 x (1 - opacity)")])])]),v._v(" "),e("ol",[e("li",[e("p",[e("code",[v._v("opacity")]),v._v("这个属性本身就是用在重叠部分颜色处理的过程中使用的，对于分层的图原来说就可以看作是与图层内容无关的系数，因为合成过程中当前层中所有像素都需要经历上面的颜色混合公式，所以"),e("code",[v._v("opacity")]),v._v("的动画过程既不会影响布局，也不需要重绘。这样图层中保存的"),e("code",[v._v("RGB")]),v._v("像素数据的缓存在动画过程中也就不需要更新了，如果不使用"),e("code",[v._v("opacity")]),v._v("属性的话，每一帧对于变化部分都需要手动重计算"),e("code",[v._v("RGB")]),v._v("颜色值（这也就相当于是重绘了），因为这些区域的像素颜色一直都在变化，缓存也就没有意义。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("transform")]),v._v("在动画过程中也不需要改变缓存的记录，而在图层合成时遍历当前层的点然后用矩阵"),e("code",[v._v("matrix")]),v._v("计算出对应的新坐标点就可以了，它也可以视作一种与图层内容无关的变换，图层中的元素首次生成的位图信息缓存可以被反复使用。"),e("strong",[v._v("比如一段平移动画，如果使用绝对定位+改变"),e("code",[v._v("left")]),v._v("值的方式来实现，就需要不断计算动画元素的布局并更新它的像素信息，但如果使用"),e("code",[v._v("translate")]),v._v("来实现，动画元素在文档流中的位置并不需要改变，无论后续平移到多远，都可以使用位图缓存中保存的初始位置信息，再加上变换矩阵的影响在层合并时计算出来，同样既不影响布局，也不需要重绘，这就是它高性能的原因。")])])])]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("transform")]),v._v("动画由"),e("code",[v._v("GPU")]),v._v("控制，支持硬件加速")])])]),v._v(" "),e("ul",[e("li",[v._v("使用"),e("code",[v._v("visibility")]),v._v("替换"),e("code",[v._v("display: none")]),v._v("，前者只会引起重绘，后者会引起回流（布局改变了）")]),v._v(" "),e("li",[v._v("不要把节点的属性值放在一个循环里当成循环的变量")]),v._v(" "),e("li",[v._v("不要使用"),e("code",[v._v("table")]),v._v("布局")]),v._v(" "),e("li",[v._v("动画速度越快，回流次数越多，可以使用"),e("code",[v._v("reuqestAnimationFrame")])]),v._v(" "),e("li",[e("code",[v._v("CSS")]),v._v("避免节点层级过多")]),v._v(" "),e("li",[v._v("将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点\n"),e("ul",[e("li",[v._v("使用"),e("code",[v._v("will-change")]),v._v("生成新图层")]),v._v(" "),e("li",[e("code",[v._v("video/iframe")]),v._v("标签")])])]),v._v(" "),e("li",[v._v("对"),e("code",[v._v("DOM")]),v._v("一系列修改时，我们可以使元素脱离文档流，对其进行多次修改，然后将元素带回到文档中。因为这个时候修改，元素已经不在渲染树中。脱离文档流方式：\n"),e("ul",[e("li",[v._v("隐藏元素，应用修改，重新显式")]),v._v(" "),e("li",[v._v("使用文档片段("),e("code",[v._v("document fragment)")]),v._v("在当前"),e("code",[v._v("DOM")]),v._v("之外构建一个子树，再把它拷贝回文档。")]),v._v(" "),e("li",[v._v("将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。")])])])]),v._v(" "),e("h2",{attrs:{id:"为什么操作dom慢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么操作dom慢"}},[v._v("#")]),v._v(" 为什么操作DOM慢")]),v._v(" "),e("blockquote",[e("p",[v._v("因为 "),e("code",[v._v("DOM")]),v._v(" 是属于渲染引擎中的东西，而 "),e("code",[v._v("JS")]),v._v(" 又是 "),e("code",[v._v("JS")]),v._v(" 引擎中的东西。当我们通过 "),e("code",[v._v("JS")]),v._v(" 操作 "),e("code",[v._v("DOM")]),v._v(" 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 "),e("code",[v._v("DOM")]),v._v(" 次数一多，也就等同于一直在进行线程之间的通信，并且操作 "),e("code",[v._v("DOM")]),v._v(" 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。")])])])}),[],!1,null,null,null);_.default=c.exports}}]);