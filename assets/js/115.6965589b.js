(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{433:function(e,v,t){"use strict";t.r(v);var s=t(33),_=Object(s.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[e._v("#")]),e._v(" WebSocket")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("Websocket")]),e._v("是一个持久化的网络通信协议，可以在单个 "),t("code",[e._v("TCP")]),e._v(" 连接上进行全双工通讯，没有了"),t("code",[e._v("Request")]),e._v("和"),t("code",[e._v("Response")]),e._v("的概念，两者地位完全平等，连接一旦建立，客户端和服务端之间实时可以进行双向数据传输")])]),e._v(" "),t("h2",{attrs:{id:"关联和区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关联和区别"}},[e._v("#")]),e._v(" 关联和区别")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("HTTP")])])]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("HTTP")]),e._v("是非持久的协议，客户端想知道服务端的处理进度只能通过不停地使用 "),t("code",[e._v("Ajax")]),e._v("进行轮询或者采用 "),t("code",[e._v("long poll")]),e._v(" 的方式来，但是前者对服务器压力大，后者则会因为一直等待"),t("code",[e._v("Response")]),e._v("造成阻塞。")]),e._v(" "),t("li",[e._v("虽然"),t("code",[e._v("http1.1")]),e._v("默认开启了"),t("code",[e._v("keep-alive")]),e._v("长连接保持了这个"),t("code",[e._v("TCP")]),e._v("通道使得在一个HTTP连接中，可以发送多个"),t("code",[e._v("Request")]),e._v("，接收多个"),t("code",[e._v("Response")]),e._v("，但是一个"),t("code",[e._v("request")]),e._v("只能有一个"),t("code",[e._v("response")]),e._v("。而且这个"),t("code",[e._v("response")]),e._v("也是被动的，不能主动发起。")]),e._v(" "),t("li",[t("code",[e._v("websocket")]),e._v("虽然是独立于"),t("code",[e._v("HTTP")]),e._v("的一种协议，但是"),t("code",[e._v("websocket")]),e._v("必须依赖 "),t("code",[e._v("HTTP")]),e._v(" 协议进行一次握手(在握手阶段是一样的)，握手成功后，数据就直接从 "),t("code",[e._v("TCP")]),e._v("通道传输，与 "),t("code",[e._v("HTTP")]),e._v(" 无关了")])])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("socket")])])]),e._v(" "),t("ol",[t("li",[t("code",[e._v("socket")]),e._v("也被称为套接字，与"),t("code",[e._v("HTTP")]),e._v("和"),t("code",[e._v("WebSocket")]),e._v("不一样，"),t("code",[e._v("socket")]),e._v("不是协议，它是在程序层面上对传输层协议（可以主要理解为"),t("code",[e._v("TCP/IP")]),e._v("）的接口封装。可以理解为一个能够提供端对端的通信的调用接口（"),t("code",[e._v("API")]),e._v("）")]),e._v(" "),t("li",[e._v("对于程序员而言，其需要在 "),t("code",[e._v("A")]),e._v(" 端创建一个 "),t("code",[e._v("socket")]),e._v(" 实例，并为这个实例提供其所要连接的 "),t("code",[e._v("B")]),e._v(" 端的 "),t("code",[e._v("IP")]),e._v(" 地址和端口号，而在 B 端创建另一个 "),t("code",[e._v("socket")]),e._v(" 实例，并且绑定本地端口号来进行监听。当 "),t("code",[e._v("A")]),e._v(" 和 "),t("code",[e._v("B")]),e._v(" 建立连接后，双方就建立了一个端对端的 "),t("code",[e._v("TCP")]),e._v(" 连接，从而可以进行双向通信。"),t("code",[e._v("WebSocekt")]),e._v("借鉴了 "),t("code",[e._v("socket")]),e._v(" 的思想，为 "),t("code",[e._v("client")]),e._v(" 和 "),t("code",[e._v("server")]),e._v(" 之间提供了类似的双向通信机制")])]),e._v(" "),t("h2",{attrs:{id:"websocket握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket握手"}},[e._v("#")]),e._v(" "),t("code",[e._v("websocket")]),e._v("握手")]),e._v(" "),t("ul",[t("li",[e._v("握手请求报文：")])]),e._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token request-line"}},[t("span",{pre:!0,attrs:{class:"token property"}},[e._v("GET")]),e._v(" /chat HTTP/1.1")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Host:")]),e._v(" server.example.com\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Upgrade:")]),e._v(" websocket\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Connection:")]),e._v(" Upgrade\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Key:")]),e._v(" x3JJHMbDL1EzLkh9GBhXDw==\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Protocol:")]),e._v(" chat, superchat\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Version:")]),e._v(" 13\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Origin:")]),e._v(" http://example.com\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("ol",[t("li",[t("code",[e._v("Sec-WebSocket-Key")]),e._v(" 是由浏览器随机生成的，验证是否可以进行"),t("code",[e._v("Websocke")]),e._v("t通信，防止恶意或者无意的连接。")]),e._v(" "),t("li",[t("code",[e._v("Sec_WebSocket-Protocol")]),e._v("是用户自定义的字符串，用来标识服务所需要的协议")]),e._v(" "),t("li",[t("code",[e._v("Sec-WebSocket-Version")]),e._v(" 表示支持的 "),t("code",[e._v("WebSocket")]),e._v(" 版本。")])]),e._v(" "),t("ul",[t("li",[e._v("服务器响应")])]),e._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token response-status"}},[e._v("HTTP/1.1 "),t("span",{pre:!0,attrs:{class:"token property"}},[e._v("101 Switching Protocols")])]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Upgrade:")]),e._v(" websocket\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Connection:")]),e._v(" Upgrade\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Accept:")]),e._v(" HSmrc0sMlYUkAGmm5OPpG2HaGWk=\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Protocol:")]),e._v(" chat\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("ol",[t("li",[t("code",[e._v("101")]),e._v(" 响应码 表示要转换协议。")]),e._v(" "),t("li",[t("code",[e._v("Connection: Upgrade")]),e._v(" 表示升级新协议请求。")]),e._v(" "),t("li",[t("code",[e._v("Upgrade: websocket")]),e._v(" 表示升级为 "),t("code",[e._v("WebSocket")]),e._v(" 协议。")]),e._v(" "),t("li",[t("code",[e._v("Sec-WebSocket-Accept")]),e._v(" 是经过服务器确认，并且加密过后的 "),t("code",[e._v("Sec-WebSocket-Key")]),e._v("。用来证明客户端和服务器之间能进行通信了。")]),e._v(" "),t("li",[t("code",[e._v("Sec-WebSocket-Protocol")]),e._v(" 表示最终使用的协议。")])]),e._v(" "),t("h2",{attrs:{id:"关于websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于websocket"}},[e._v("#")]),e._v(" 关于websocket")]),e._v(" "),t("h3",{attrs:{id:"websocket心跳"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket心跳"}},[e._v("#")]),e._v(" websocket心跳")]),e._v(" "),t("p",[e._v("可能会有一些未知情况导致"),t("code",[e._v("SOCKET")]),e._v("断开，而客户端和服务端却不知道，需要客户端定时发送一个心跳 "),t("code",[e._v("Ping")]),e._v(" 让服务端知道自己在线，而服务端也要回复一个心跳 "),t("code",[e._v("Pong")]),e._v("告诉客户端自己可用，否则视为断开")]),e._v(" "),t("h3",{attrs:{id:"websocket状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket状态"}},[e._v("#")]),e._v(" websocket状态")]),e._v(" "),t("p",[t("code",[e._v("WebSocket")]),e._v(" 对象中的"),t("code",[e._v("readyState")]),e._v("属性有四种状态：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("0:")]),e._v(" 表示正在连接")]),e._v(" "),t("li",[t("code",[e._v("1")]),e._v(": 表示连接成功，可以通信了")]),e._v(" "),t("li",[t("code",[e._v("2")]),e._v(": 表示连接正在关闭")]),e._v(" "),t("li",[t("code",[e._v("3")]),e._v(": 表示连接已经关闭，或者打开连接失败")])]),e._v(" "),t("p",[e._v("文章摘录自前端久遇 ，作者johnYu")]),e._v(" "),t("h2",{attrs:{id:"从实时通信系统看http发展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从实时通信系统看http发展"}},[e._v("#")]),e._v(" 从实时通信系统看HTTP发展")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("轮询\n客户端定期发送"),t("code",[e._v("AJAX")]),e._v("请求，服务端在受理请求后会立刻返回数据。这种方式保证了数据的相对实时性，具有很好的浏览器兼容性和简单性。但是，其缺点也很明显。比如数据延迟取决于轮询频率，如果频率过高就会产生大量无效请求；如果频率过低，数据的实时性会较差。同事服务器端的压力会比较大，从而浪费带宽流量。")])]),e._v(" "),t("li",[t("p",[e._v("长轮询\n客户端通过"),t("code",[e._v("AJAX")]),e._v("请求，服务器端在接收到请求后不马上返回，而是保持这个连接，等待数据更新。当有数据需要推送给客户端时，服务器端才将目标数据发送给客户端，返回请求。客户端收到响应后，马上再发起一个新的请求给服务器端，周而复始。这样的长轮询能够有效减小轮询次数，而且大大降低延迟，但服务器需要保持大量连接，会产生一定损耗。")])]),e._v(" "),t("li",[t("p",[e._v("WebSocket\n也是应用层协议，基于"),t("code",[e._v("TCP")]),e._v("来传输数据。依赖一种升级的"),t("code",[e._v("HTTP")]),e._v("进行一次握手，握手成功后，数据就可以直接在"),t("code",[e._v("TCP")]),e._v("通道中传输了。")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);